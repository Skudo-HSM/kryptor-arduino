/**************************************************
 *                                                *
 *      Skudo OÜ HSM - Arduino interface library  *
 *                                                *
 *          Version 1.0 September 2021            *
 *              Copyright Skudo OÜ                *
 *                www.skudo.tech                  *
 **************************************************/

/*
 Arduino Nano Circuit:
 CSB: pin 10
 MOSI: pin 11
 MISO: pin 12
 SCK: pin 13

*/

#include <SPI.h>

#include "spi_functions.h"
#include "hsm_cli.h"

// chipselect line on arduino nano is pin 10
const int chipSelectPin = 10;


// Functions providing SPI access to the HSM library functions
void assert_cs()
{
  digitalWrite(chipSelectPin, LOW);  
}

void deassert_cs()
{
  digitalWrite(chipSelectPin, HIGH);  
}

void send_request(const unsigned char* buf, size_t size)
{
  assert_cs();
  for(size_t i = 0; i<size; ++i)
    SPI.transfer(buf[i]);
}

void complete_request(const unsigned char* buf, size_t size)
{
  send_request(buf, size);
  deassert_cs();
}

void read_reply(unsigned char* buf, size_t size)
{
  for(size_t i = 0; i<size; ++i)
    buf[i] = SPI.transfer(0);
  deassert_cs();
}

// convenience functions to print debugging data into serial port
void print_blob(unsigned char* data, size_t size)
{
  char txt[3];
  for(size_t i=0; i<size; ++i)
  {
    snprintf(txt, sizeof txt, "%02x", data[i]);
    Serial.print(txt);
  }
  Serial.println("");
}

// read the hardware string and print it into serial port
void print_string(const char *title, int id)
{
  char buf[64];
  char text_line[64];
  read_string(id, text_line, sizeof text_line);
  snprintf(buf, sizeof buf, "%s\n", text_line);
  Serial.print(title);
  Serial.print(buf);
}

// print the key data response from hw
void print_keyr(const char *title, KeyResponse* keyr)
{
  Serial.print(title);
  if(keyr->valid)
    print_blob(keyr->key, keyr->length);
  else
    Serial.println("Invalid");
}

void print_hw_attributes()
{
  print_string("Vendor:  ", HSM_VENDOR_ID);
  print_string("Product: ", HSM_PRODUCT_ID);
  print_string("Serial:  ", HSM_READ_SERIAL);
  Serial.println("");  
}

// convenience function to read out the output of some encryption job
size_t read_blob_buffer(unsigned char* output_buf)
{
  unsigned char msg_buf[256];
  wait_ready();
  read_blob(msg_buf, sizeof msg_buf);
  
  BlobResponse* blob = (BlobResponse*)msg_buf;
  memcpy(output_buf, msg_buf+sizeof(BlobResponse), blob->size);
  return blob->size;  
}

size_t encrypt_message(int slot_idx, const unsigned char* text, size_t length, unsigned char* output_buf)
{
  Serial.print("Message len: ");
  Serial.println(length);

  encrypt_block(slot_idx, 0, 0, text, length);
  return read_blob_buffer(output_buf);
}

void decrypt_message(int slot_idx, const unsigned char* data, size_t size, unsigned char* output_buf)
{
  Serial.println("Decrypting data...");
  decrypt_block(slot_idx, 0, 0, data, size);
  read_blob_buffer(output_buf);
}

void demo_encryption()
{
  const unsigned char* message = "Hello world";
  const int slot = SLOT0;
  
  // generate random symmetric key
  setup_key(slot, SYMMETRIC_KEYS, GENERATE_RANDOM_KEY, 0);
  wait_ready();

  // show the key generated
  KeyResponse key;
  read_key(slot, SYMMETRIC_KEYS, &key);
  print_keyr("Symmetric key: ", &key);
 
  // encrypt the data
  unsigned char buffer[256];
  size_t size = encrypt_message(slot, message, strlen(message)+1, buffer);
  Serial.print("Encrypted block len: ");
  Serial.println(size);
  print_blob(buffer, size);

  // decrypt the encrypted blob
  decrypt_message(slot, buffer, size, buffer);
  Serial.print("Decrypted message: ");
  Serial.println((const char*)buffer);
}

// read out the random bytes generated by TRNG
void demo_trng()
{
  Serial.println("Random bytes:");
  const int blocks = 4;
  const int size = 16;
  unsigned char buf[size];
  
  for(int i=0; i<blocks; ++i)
  {
    get_random_bytes(buf, size);
    print_blob(buf, size);
  }
  Serial.println();
}

// show how two parties can negotiate shared secret using Elliptic-curve Diffie-Hellman
// function Curve25519

void demo_ecdh()
{
  // assign slots to the local and remote parties keys
  const int local_key_slot = SLOT0;
  const int remote_key_slot = SLOT1;

  // generate ephemeral keypairs, use different key slots to emulate
  // both local and remote parties
  
  // "local" ephemeral keypair
  setup_key(local_key_slot, KEYPAIRS, GENERATE_RANDOM_KEY, 0);
  wait_ready();
  
  // read local public key
  KeyResponse local_pub_key;
  read_key(local_key_slot, KEYPAIRS, &local_pub_key);
  print_keyr("Local public: ", &local_pub_key);

  // "remote" ephemeral keypair
  setup_key(remote_key_slot, KEYPAIRS, GENERATE_RANDOM_KEY, 0);
  wait_ready();

  KeyResponse remote_pub_key;
  read_key(remote_key_slot, KEYPAIRS, &remote_pub_key);
  print_keyr("Remote public: ", &remote_pub_key);

  // find shared secret on local side
  setup_ecdh_key(local_key_slot, SLOT2, remote_pub_key.key);
  wait_ready();
  
  KeyResponse local_shared_secret;
  read_key(SLOT2, SYMMETRIC_KEYS, &local_shared_secret);
  print_keyr("Local secret: ", &local_shared_secret);
  
  // find shared_secret on remote side
  setup_ecdh_key(remote_key_slot, SLOT3, local_pub_key.key);
  wait_ready();
  
  KeyResponse remote_shared_secret;
  read_key(SLOT3, SYMMETRIC_KEYS, &remote_shared_secret);
  print_keyr("Remote secret: ", &remote_shared_secret);
}


void demo_hashing()
{
  const char *msg1 = "Hello";
  const char *msg2 = " World";
  const char *msg3 = " !";

  // Skein was a contender for SHA-3, and it allows for variable sizes of hashes
  // This hw is using Skein with 256 bits internal state size
  
  // desired size of the output hash value in bytes
  const int hash_size = 16;

  // init the hash with first block of data
  Serial.println("Start with msg1...");
  hash_block(hash_size, 0, msg1, strlen(msg1));
  wait_ready();
  
  // continue hashing
  Serial.println("Add msg2...");
  hash_block(0, 0, msg2, strlen(msg2));
  wait_ready();
 
  // finalize hashing
  Serial.println("Finalize with msg3...");
  hash_block(0, 1, msg3, strlen(msg3));
  wait_ready();

  unsigned char buffer[32];
  size_t length = read_blob_buffer(buffer);
  Serial.println("Skein-256-128: ");
  print_blob(buffer, hash_size);
}

void setup() {
  Serial.begin(115200);

  // start the SPI library:
  SPI.begin();
  SPI.setClockDivider(SPI_CLOCK_DIV64);

  // initalize the  data ready and chip select pins:
  pinMode(chipSelectPin, OUTPUT);
  deassert_cs();

  if(!validate_protocol())
  {
    Serial.println("Hardware protocol version mismatch");
    return;
  }

  print_hw_attributes();

  demo_trng();
  demo_encryption();
  demo_ecdh();
  demo_hashing();
}

void loop() {
}
